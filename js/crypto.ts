/**
 * @fileoverview Encryption utilities for secure localStorage
 *
 * Provides AES-GCM encryption for sensitive data stored in localStorage.
 * Uses the Web Crypto API for secure, browser-native encryption.
 *
 * ## Security Model
 * - Uses AES-GCM with 256-bit keys
 * - Each encryption operation uses a unique IV (Initialization Vector)
 * - Per-workspace random key generated by Web Crypto API
 * - Key stored in IndexedDB (non-extractable) for persistence
 *
 * ## Limitations
 * - Clearing site data removes the stored key and makes existing data unreadable
 * - In-memory fallback is used when IndexedDB is unavailable (non-persistent)
 *
 * ## Usage
 * ```typescript
 * const key = await deriveEncryptionKey('workspace-123');
 * const encrypted = await encryptData('sensitive-data', key);
 * const decrypted = await decryptData(encrypted, key);
 * ```
 */

import { createLogger } from './logger.js';
import { safeGetItem, safeSetItem } from './storage.js';

const logger = createLogger('Crypto');

/**
 * Error thrown when AES-GCM authentication tag validation fails.
 * This indicates data tampering or use of an incorrect decryption key.
 */
export class AuthenticationError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'AuthenticationError';
    }
}

/**
 * Algorithm configuration for AES-GCM encryption.
 */
const ALGORITHM = 'AES-GCM';
const KEY_LENGTH = 256;
const IV_LENGTH = 12; // 96 bits, recommended for AES-GCM
const AUTH_TAG_LENGTH = 128; // 128-bit authentication tag (maximum security)
const PBKDF2_ITERATIONS = 100000;
const SALT_PREFIX = 'otplus-encryption-salt-v1';

const KEY_DB_NAME = 'otplus-encryption-keys';
const KEY_DB_VERSION = 1;
const KEY_STORE_NAME = 'keys';

const GLOBAL_FALLBACK_KEY_STORE = '__OTPLUS_FALLBACK_KEY_STORE__';

const keyCache = new Map<string, CryptoKey>();
const pendingKeyPromises = new Map<string, Promise<CryptoKey>>();

const fallbackKeyStore: Map<string, CryptoKey> = (() => {
    if (typeof globalThis === 'undefined') {
        return new Map<string, CryptoKey>();
    }
    const globalObject = globalThis as unknown as Record<string, unknown>;
    if (!globalObject[GLOBAL_FALLBACK_KEY_STORE]) {
        globalObject[GLOBAL_FALLBACK_KEY_STORE] = new Map<string, CryptoKey>();
    }
    return globalObject[GLOBAL_FALLBACK_KEY_STORE] as Map<string, CryptoKey>;
})();

/**
 * Encrypted data format stored in localStorage.
 */
export interface EncryptedData {
    /** Base64-encoded ciphertext */
    ct: string;
    /** Base64-encoded initialization vector */
    iv: string;
    /** Version for future format upgrades */
    v: number;
}

function isIndexedDbAvailable(): boolean {
    return typeof indexedDB !== 'undefined';
}

let keyDatabasePromise: Promise<IDBDatabase> | null = null;

async function openKeyDatabase(): Promise<IDBDatabase> {
    if (!isIndexedDbAvailable()) {
        throw new Error('IndexedDB not available');
    }

    if (!keyDatabasePromise) {
        keyDatabasePromise = new Promise<IDBDatabase>((resolve, reject) => {
            const request = indexedDB.open(KEY_DB_NAME, KEY_DB_VERSION);

            request.onupgradeneeded = () => {
                const db = request.result;
                if (!db.objectStoreNames.contains(KEY_STORE_NAME)) {
                    db.createObjectStore(KEY_STORE_NAME);
                }
            };

            request.onsuccess = () => {
                resolve(request.result);
            };

            request.onerror = () => {
                reject(request.error || new Error('Failed to open IndexedDB'));
            };
        });
    }

    return keyDatabasePromise;
}

async function persistKey(workspaceId: string, key: CryptoKey): Promise<boolean> {
    if (!isIndexedDbAvailable()) {
        return false;
    }

    try {
        const db = await openKeyDatabase();
        await new Promise<void>((resolve, reject) => {
            const tx = db.transaction(KEY_STORE_NAME, 'readwrite');
            const store = tx.objectStore(KEY_STORE_NAME);
            const request = store.put(key, workspaceId);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error || new Error('Failed to store key'));
        });
        return true;
    } catch (error) {
        logger.warn('Failed to persist encryption key to IndexedDB', { error });
        return false;
    }
}

/**
 * Derives (or loads) an encryption key for a workspace.
 *
 * Uses a per-workspace AES-GCM key that is stored in IndexedDB (non-extractable).
 * In environments without IndexedDB, falls back to an in-memory key store.
 *
 * @param workspaceId - The workspace identifier used as the storage namespace
 * @returns Promise resolving to CryptoKey suitable for AES-GCM
 */
export async function deriveEncryptionKey(
    workspaceId: string,
    _passphrase?: string
): Promise<CryptoKey> {
    if (keyCache.has(workspaceId)) {
        return keyCache.get(workspaceId)!;
    }

    const pending = pendingKeyPromises.get(workspaceId);
    if (pending) {
        return pending;
    }

    const promise = (async () => {
        const storedKeyFromDb = await (async () => {
            if (!isIndexedDbAvailable()) {
                return null;
            }

            try {
                const db = await openKeyDatabase();
                return await new Promise<CryptoKey | null>((resolve, reject) => {
                    const tx = db.transaction(KEY_STORE_NAME, 'readonly');
                    const store = tx.objectStore(KEY_STORE_NAME);
                    const request = store.get(workspaceId);
                    request.onsuccess = () => {
                        resolve((request.result as CryptoKey | undefined) || null);
                    };
                    request.onerror = () => {
                        reject(request.error || new Error('Failed to read key'));
                    };
                });
            } catch (error) {
                logger.warn('Failed to read encryption key from IndexedDB', { error });
                return null;
            }
        })();

        const storedKey = storedKeyFromDb || fallbackKeyStore.get(workspaceId) || null;
        if (storedKey) {
            keyCache.set(workspaceId, storedKey);
            return storedKey;
        }

        const key = await crypto.subtle.generateKey(
            { name: ALGORITHM, length: KEY_LENGTH },
            false,
            ['encrypt', 'decrypt']
        );

        const persisted = await persistKey(workspaceId, key);
        if (!persisted) {
            fallbackKeyStore.set(workspaceId, key);
        }

        keyCache.set(workspaceId, key);
        return key;
    })();

    pendingKeyPromises.set(workspaceId, promise);
    try {
        return await promise;
    } finally {
        pendingKeyPromises.delete(workspaceId);
    }
}

/**
 * Legacy PBKDF2-based key derivation (pre-2026).
 * Retained for decrypting data encrypted with workspaceId-derived keys.
 *
 * @internal
 */
export async function deriveLegacyEncryptionKey(
    workspaceId: string,
    passphrase?: string
): Promise<CryptoKey> {
    const encoder = new TextEncoder();

    const keyMaterialInput = passphrase
        ? `${workspaceId}:${passphrase}`
        : workspaceId;

    const saltInput = passphrase
        ? `${SALT_PREFIX}:${workspaceId}:passphrase-protected`
        : `${SALT_PREFIX}:${workspaceId}`;
    const salt = encoder.encode(saltInput);

    const keyMaterial = await crypto.subtle.importKey(
        'raw',
        encoder.encode(keyMaterialInput),
        'PBKDF2',
        false,
        ['deriveKey']
    );

    return crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt,
            iterations: PBKDF2_ITERATIONS,
            hash: 'SHA-256',
        },
        keyMaterial,
        { name: ALGORITHM, length: KEY_LENGTH },
        false,
        ['encrypt', 'decrypt']
    );
}

/**
 * Encrypts data using AES-GCM.
 *
 * @param data - The plaintext string to encrypt
 * @param key - CryptoKey derived from deriveEncryptionKey()
 * @returns Promise resolving to EncryptedData object
 */
export async function encryptData(data: string, key: CryptoKey): Promise<EncryptedData> {
    const encoder = new TextEncoder();
    const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));

    const ciphertext = await crypto.subtle.encrypt(
        { name: ALGORITHM, iv, tagLength: AUTH_TAG_LENGTH },
        key,
        encoder.encode(data)
    );

    return {
        ct: arrayBufferToBase64(ciphertext),
        iv: arrayBufferToBase64(iv.buffer),
        v: 1,
    };
}

/**
 * Decrypts data using AES-GCM.
 *
 * @param encrypted - The EncryptedData object to decrypt
 * @param key - CryptoKey derived from deriveEncryptionKey()
 * @returns Promise resolving to decrypted plaintext string
 * @throws Error if decryption fails (wrong key, tampered data, etc.)
 */
export async function decryptData(encrypted: EncryptedData, key: CryptoKey): Promise<string> {
    const decoder = new TextDecoder();
    const iv = base64ToArrayBuffer(encrypted.iv);
    const ciphertext = base64ToArrayBuffer(encrypted.ct);

    try {
        const plaintext = await crypto.subtle.decrypt(
            { name: ALGORITHM, iv, tagLength: AUTH_TAG_LENGTH },
            key,
            ciphertext
        );

        return decoder.decode(plaintext);
    } catch (error) {
        // AES-GCM decryption fails with OperationError when:
        // 1. The authentication tag doesn't match (data tampering)
        // 2. The wrong key is used
        // 3. The IV/ciphertext is corrupted
        if (error instanceof DOMException && error.name === 'OperationError') {
            throw new AuthenticationError('Data integrity check failed - possible tampering or wrong key');
        }
        throw error;
    }
}

/**
 * Stores encrypted data in localStorage (with fallback support).
 *
 * @param storageKey - The storage key to use
 * @param data - The plaintext data to encrypt and store
 * @param encryptionKey - CryptoKey for encryption
 * @returns Promise resolving to true on success, false on failure
 */
export async function storeEncrypted(
    storageKey: string,
    data: string,
    encryptionKey: CryptoKey
): Promise<boolean> {
    try {
        const encrypted = await encryptData(data, encryptionKey);
        safeSetItem(storageKey, JSON.stringify(encrypted));
        return true;
    } catch (error) {
        logger.warn('Failed to store encrypted data', { storageKey, error });
        return false;
    }
}

/**
 * Retrieves and decrypts data from localStorage (with fallback support).
 *
 * @param storageKey - The storage key to read from
 * @param encryptionKey - CryptoKey for decryption
 * @returns Promise resolving to decrypted string, or null if not found/failed
 */
export async function retrieveEncrypted(
    storageKey: string,
    encryptionKey: CryptoKey
): Promise<string | null> {
    try {
        const stored = safeGetItem(storageKey);
        if (!stored) return null;

        const encrypted = JSON.parse(stored) as EncryptedData;

        // Verify format version
        if (encrypted.v !== 1) {
            logger.warn('Unknown encrypted data version', { storageKey, version: encrypted.v });
            return null;
        }

        return await decryptData(encrypted, encryptionKey);
    } catch (error) {
        logger.warn('Failed to retrieve encrypted data', { storageKey, error });
        return null;
    }
}

/**
 * Checks if the Web Crypto API is available.
 *
 * @returns true if encryption is supported, false otherwise
 */
export function isEncryptionSupported(): boolean {
    return typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined';
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Converts an ArrayBuffer to a Base64 string.
 */
function arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
}

/**
 * Converts a Base64 string to an ArrayBuffer.
 */
function base64ToArrayBuffer(base64: string): ArrayBuffer {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes.buffer;
}

const isProductionEnv =
    typeof process !== 'undefined' && process.env?.NODE_ENV === 'production';

// Expose encryption check on window for debugging (non-production only)
/* istanbul ignore next -- browser-only global */
if (typeof window !== 'undefined' && !isProductionEnv) {
    (window as unknown as Record<string, unknown>).__OTPLUS_CRYPTO__ = {
        isSupported: isEncryptionSupported,
    };
}
